"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arcToCubic = exports.rotateVector = void 0;
function rotateVector(x, y, rad) {
    var X = x * Math.cos(rad) - y * Math.sin(rad);
    var Y = x * Math.sin(rad) + y * Math.cos(rad);
    return { x: X, y: Y };
}
exports.rotateVector = rotateVector;
// for more information of where this math came from visit:
// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
// LAF = largeArcFlag, SF = sweepFlag
function arcToCubic(x1, y1, rx, ry, angle, LAF, SF, x2, y2, recursive) {
    var d120 = (Math.PI * 120) / 180;
    var rad = (Math.PI / 180) * (angle || 0);
    var res = [];
    var X1 = x1;
    var X2 = x2;
    var Y1 = y1;
    var Y2 = y2;
    var RX = rx;
    var RY = ry;
    var xy;
    var f1;
    var f2;
    var cx;
    var cy;
    if (!recursive) {
        xy = rotateVector(X1, Y1, -rad);
        X1 = xy.x;
        Y1 = xy.y;
        xy = rotateVector(X2, Y2, -rad);
        X2 = xy.x;
        Y2 = xy.y;
        var x = (X1 - X2) / 2;
        var y = (Y1 - Y2) / 2;
        var h = (x * x) / (RX * RY) + (Math.pow(y, 2)) / (Math.pow(RY, 2));
        if (h > 1) {
            h = Math.sqrt(h);
            RX *= h;
            RY *= h;
        }
        var rx2 = Math.pow(RX, 2);
        var ry2 = Math.pow(RY, 2);
        var k = (LAF === SF ? -1 : 1)
            * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x)
                / (rx2 * y * y + ry2 * x * x)));
        cx = ((k * RX * y) / RY) + ((X1 + X2) / 2);
        cy = ((k * -RY * x) / RX) + ((Y1 + Y2) / 2);
        f1 = Math.asin((((Y1 - cy) / RY) * Math.pow(10, 9) >> 0) / (Math.pow(10, 9)));
        f2 = Math.asin((((Y2 - cy) / RY) * Math.pow(10, 9) >> 0) / (Math.pow(10, 9)));
        f1 = X1 < cx ? Math.PI - f1 : f1;
        f2 = X2 < cx ? Math.PI - f2 : f2;
        if (f1 < 0)
            f1 = Math.PI * 2 + f1;
        if (f2 < 0)
            f2 = Math.PI * 2 + f2;
        if (SF && f1 > f2) {
            f1 -= Math.PI * 2;
        }
        if (!SF && f2 > f1) {
            f2 -= Math.PI * 2;
        }
    }
    else {
        var r1 = recursive[0], r2 = recursive[1], r3 = recursive[2], r4 = recursive[3];
        f1 = r1;
        f2 = r2;
        cx = r3;
        cy = r4;
    }
    var df = f2 - f1;
    if (Math.abs(df) > d120) {
        var f2old = f2;
        var x2old = X2;
        var y2old = Y2;
        f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
        X2 = cx + RX * Math.cos(f2);
        Y2 = cy + RY * Math.sin(f2);
        res = arcToCubic(X2, Y2, RX, RY, angle, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = Math.cos(f1);
    var s1 = Math.sin(f1);
    var c2 = Math.cos(f2);
    var s2 = Math.sin(f2);
    var t = Math.tan(df / 4);
    var hx = (4 / 3) * RX * t;
    var hy = (4 / 3) * RY * t;
    var m1 = [X1, Y1];
    var m2 = [X1 + hx * s1, Y1 - hy * c1];
    var m3 = [X2 + hx * s2, Y2 - hy * c2];
    var m4 = [X2, Y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];
    if (recursive) {
        return [m2, m3, m4].concat(res);
    }
    res = [m2, m3, m4].concat(res).join().split(',');
    return res.map(function (rz, i) {
        if (i % 2) {
            return rotateVector(res[i - 1], rz, rad).y;
        }
        return rotateVector(rz, res[i + 1], rad).x;
    });
}
exports.arcToCubic = arcToCubic;
//# sourceMappingURL=arc-2-cubic.js.map